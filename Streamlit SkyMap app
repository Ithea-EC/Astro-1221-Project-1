"""
Streamlit app: sky map using the animate_sky-style figure from CodeForStreamlit1.
Select a constellation (click equivalent) to show the LLM Storyteller mythology in a box below.
Run with: streamlit run streamlit_sky_map_app.py
"""

import importlib.util
import sys
from pathlib import Path
from importlib.machinery import SourceFileLoader

import os

import matplotlib.pyplot as plt
import streamlit as st

try:
    from streamlit.errors import StreamlitSecretNotFoundError
except ImportError:
    StreamlitSecretNotFoundError = Exception  # older Streamlit

# Load CodeForStreamlit1 (no .py extension)
SCRIPT_DIR = Path(__file__).resolve().parent
for name in ("CodeForStreamlit1", "CodeForStreamlit1.py"):
    code_path = SCRIPT_DIR / name
    if code_path.exists():
        break
else:
    code_path = SCRIPT_DIR / "CodeForStreamlit1"

loader = SourceFileLoader("code_for_streamlit", str(code_path))
spec = importlib.util.spec_from_loader("code_for_streamlit", loader)
code_module = importlib.util.module_from_spec(spec)
sys.modules["code_for_streamlit"] = code_module
spec.loader.exec_module(code_module)

generate_stars = code_module.generate_stars
create_constellations = code_module.create_constellations
get_static_sky_figure = code_module.get_static_sky_figure
AdvancedStoryTeller = code_module.AdvancedStoryTeller


@st.cache_data
def get_universe(seed=None, num_stars=400):
    """Generate stars and constellations once."""
    stars = generate_stars(num_stars=num_stars, seed=seed)
    constellations = create_constellations(stars, max_distance=0.35, min_spacing=0.15)
    # Assign placeholder mythology so labels show "Constellation N" until LLM is used
    for c in constellations:
        if not c.mythology or c.mythology == "Unknown":
            c.mythology = f"Constellation {c.cid}: (click to generate myth)"
    return stars, constellations


def _constellation_label(c, mythology_cache):
    """Display name for dropdown: from cache if generated, else Constellation N."""
    if c.cid in mythology_cache:
        return mythology_cache[c.cid].get("name") or f"Constellation {c.cid}"
    return f"Constellation {c.cid}"


def main():
    st.set_page_config(page_title="Sky Map", page_icon="ðŸŒŒ", layout="centered")
    st.title("Sky Map: Constellations & Mythology")
    st.markdown(
        "The sky map below uses the same **animate_sky** view from CodeForStreamlit1. "
        "**Select a constellation** from the dropdown under the map to see the mythology the LLM Storyteller creates."
    )

    if "mythology_cache" not in st.session_state:
        st.session_state.mythology_cache = {}
    if "storyteller" not in st.session_state:
        api_key = ""
        proxy_url = "https://litellmproxy.osu-ai.org/v1"
        try:
            api_key = st.secrets.get("osu_litellm_api_key", "") or st.secrets.get("api_key", "")
            proxy_url = st.secrets.get("osu_litellm_proxy_url", proxy_url)
        except StreamlitSecretNotFoundError:
            pass
        if not api_key:
            api_key = os.environ.get("OSU_LITELLM_API_KEY", "")
        st.session_state.storyteller = None
        st.session_state.storyteller_api_key = api_key
        st.session_state.storyteller_proxy_url = proxy_url

    seed = st.sidebar.number_input("Random seed", min_value=0, value=42, step=1)
    num_stars = st.sidebar.slider("Number of stars", 100, 600, 400, 50)

    with st.spinner("Generating star fieldâ€¦"):
        stars, constellations = get_universe(seed=seed, num_stars=num_stars)

    time_hours = 21.0  # Fixed simulated time (9 PM)

    # Build LLM name overrides so the map shows constellation names once generated
    mythology_cache = st.session_state.mythology_cache
    name_overrides = {cid: mythology_cache[cid]["name"] for cid in mythology_cache if mythology_cache[cid].get("name")}

    # Sky map: static frame of animate_sky
    fig = get_static_sky_figure(stars, constellations, time_hours=time_hours, name_overrides=name_overrides)
    st.pyplot(fig)
    plt.close(fig)

    st.subheader("Select a constellation")
    selected_index = st.selectbox(
        "Choose a constellation to view its mythology (generated by the LLM Storyteller):",
        options=range(len(constellations)),
        format_func=lambda i: _constellation_label(constellations[i], mythology_cache),
        index=0,
        key="const_select",
    )
    selected_cid = constellations[selected_index].cid

    # Ensure we have mythology for the selected constellation
    if selected_cid is not None:
        selected_const = next((c for c in constellations if c.cid == selected_cid), None)
        if selected_const is not None and selected_cid not in mythology_cache:
            api_key = st.session_state.storyteller_api_key
            proxy_url = st.session_state.storyteller_proxy_url
            if api_key:
                if st.session_state.storyteller is None:
                    st.session_state.storyteller = AdvancedStoryTeller(api_key=api_key, proxy_url=proxy_url)
                with st.spinner("Asking the Storyteller for this constellationâ€™s mythâ€¦"):
                    name, story = st.session_state.storyteller.generate_myth(selected_const)
                st.session_state.mythology_cache[selected_cid] = {"name": name, "story": story}
                selected_const.mythology = f"{name}: {story}"

    # Mythology box under the sky map
    st.markdown("---")
    if selected_cid is not None and selected_cid in mythology_cache:
        cached = mythology_cache[selected_cid]
        name = cached.get("name", f"Constellation {selected_cid}")
        story = cached.get("story", "")
        st.subheader(f"ðŸ“œ {name}")
        st.info(story)
    elif selected_cid is not None:
        st.info(
            "Set your OSU LiteLLM API key in `.streamlit/secrets.toml` (e.g. `osu_litellm_api_key`) "
            "or in the environment as `OSU_LITELLM_API_KEY` to generate mythology for this constellation."
        )
    else:
        st.caption("Select a constellation above to see its mythology here.")


if __name__ == "__main__":
    try:
        from streamlit.runtime.scriptrunner import get_script_run_ctx
        if get_script_run_ctx() is None:
            raise RuntimeError("Not in Streamlit")
        main()
    except Exception:
        import subprocess
        subprocess.run([sys.executable, "-m", "streamlit", "run", str(Path(__file__).resolve()), *sys.argv[1:]])
